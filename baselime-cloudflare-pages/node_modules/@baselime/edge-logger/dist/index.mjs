// src/index.ts
var tracingApiPromise;
try {
  tracingApiPromise = import("@opentelemetry/api");
} catch (_) {
  tracingApiPromise = Promise.resolve(null);
}
var BaselimeLogger = class {
  ctx;
  apiKey;
  dataset;
  service;
  namespace;
  logs = [];
  requestId;
  // flushTimeout is a timeout set by setTimeout() to flush the logs after a certain amount of time
  flushTimeout = null;
  flushPromise = null;
  flushAfterMs;
  flushAfterLogs;
  baselimeUrl;
  isLocalDev;
  constructor(args) {
    this.ctx = args.ctx;
    this.apiKey = args.apiKey;
    this.dataset = args.dataset;
    this.service = args.service;
    this.namespace = args.namespace;
    this.flushAfterMs = args.flushAfterMs ?? 1e4;
    this.flushAfterLogs = args.flushAfterLogs ?? 100;
    this.baselimeUrl = args.baselimeUrl ?? "https://events.baselime.io/v1";
    if (args.requestId) {
      this.requestId = args.requestId;
    } else {
      this.requestId = crypto.randomUUID();
    }
    this.isLocalDev = args.isLocalDev;
  }
  async _log(message, level, data) {
    const tracingApi = await tracingApiPromise;
    let traceId;
    if (tracingApi) {
      const span = tracingApi.trace.getActiveSpan();
      traceId = span == null ? void 0 : span.spanContext().traceId;
    }
    if (this.isLocalDev) {
      const colors = {
        info: "\x1B[32m",
        warning: "${colors[log.level]",
        error: "\x1B[31m",
        debug: "\x1B[35m"
      };
      const grey = `\x1B[90m`;
      const white = `\x1B[0m`;
      console.log(
        `${colors[level]}${level}${grey} - ${this.requestId} - ${white}${message}`
      );
      if (data) {
        console.log(`${grey} ${JSON.stringify(data, null, 2)}`);
      }
      return;
    }
    if (!this.apiKey || !this.ctx) {
      console.log(
        JSON.stringify({
          message,
          level,
          ...data,
          requestId: this.requestId,
          traceId: data == null ? void 0 : data.traceId
        })
      );
    }
    if (data && data.level) {
      level = data.level;
      delete data.level;
    }
    const log = {
      message,
      level,
      traceId,
      requestId: this.requestId,
      ...data
    };
    this.logs.push(log);
    if (this.logs.length >= this.flushAfterLogs) {
      if (this.flushTimeout) {
        this.scheduleFlush(this.flushAfterMs, true);
      }
      this.ctx.waitUntil(this.flush({ skipIfInProgress: true }));
    } else {
      this.scheduleFlush(this.flushAfterMs);
    }
  }
  /** Flush after X ms if there's not already
   * a flush scheduled
   * @param reset If true, cancel the current flush timeout
   */
  scheduleFlush(timeout, reset = false) {
    if (reset && this.flushTimeout) {
      clearTimeout(this.flushTimeout);
      this.flushTimeout = null;
    }
    if (!this.flushTimeout && !this.flushPromise) {
      this.flushTimeout = setTimeout(() => {
        const doFlush = async () => {
          this.flush({ skipIfInProgress: true });
          this.flushTimeout = null;
        };
        this.ctx.waitUntil(doFlush());
      }, timeout);
    }
  }
  async flush({
    skipIfInProgress = false
  } = {}) {
    if (skipIfInProgress && this.flushPromise)
      return;
    const doFlush = async () => {
      if (this.logs.length === 0)
        return;
      const logsCount = this.logs.length;
      const logsBody = JSON.stringify(this.logs);
      try {
        const res = await fetch(`${this.baselimeUrl}/${this.dataset}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-api-key": this.apiKey,
            "x-service": this.service,
            "x-namespace": this.namespace
          },
          body: logsBody
        });
        if (res.ok) {
          this.logs.splice(0, logsCount);
          await res.arrayBuffer();
        } else {
          console.log(
            `Baselime failed to ingest logs: ${res.status} ${res.statusText} ${await res.text()}`
          );
        }
      } catch (err) {
        console.error(`Baselime failed to ingest logs: ${err}`);
      }
    };
    await this.flushPromise;
    this.flushPromise = doFlush();
    await this.flushPromise;
    this.flushPromise = null;
  }
  log(msg, data) {
    this._log(msg, "info", data);
  }
  info(msg, data) {
    this._log(msg, "info", data);
  }
  warn(msg, data) {
    this._log(msg, "warning", data);
  }
  error(msg, data) {
    let m = "";
    if (msg instanceof Error) {
      m = msg.message + (msg.stack ? `: ${msg.stack}` : "");
    } else if (typeof msg === "string") {
      m = msg;
    } else {
      m = JSON.stringify(msg);
    }
    this._log(m, "error", data);
  }
  debug(msg, data) {
    this._log(msg, "debug", data);
  }
};
export {
  BaselimeLogger
};
