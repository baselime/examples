/*
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Original version by long.js: https://github.com/dcodeIO/long.js/
var TWO_PWR_32 = (1 << 16) * (1 << 16);
var UnsignedLong = /** @class */ (function () {
    function UnsignedLong(low, high) {
        this.low = low;
        this.high = high;
    }
    UnsignedLong.fromU32 = function (value) {
        return new UnsignedLong(value % TWO_PWR_32 | 0, 0);
    };
    UnsignedLong.prototype.multiply = function (value) {
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xffff;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xffff;
        var b48 = value.high >>> 16;
        var b32 = value.high & 0xffff;
        var b16 = value.low >>> 16;
        var b00 = value.low & 0xffff;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xffff;
        return new UnsignedLong((c16 << 16) | c00, (c48 << 16) | c32);
    };
    UnsignedLong.prototype.add = function (value) {
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xffff;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xffff;
        var b48 = value.high >>> 16;
        var b32 = value.high & 0xffff;
        var b16 = value.low >>> 16;
        var b00 = value.low & 0xffff;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 + b48;
        c48 &= 0xffff;
        return new UnsignedLong((c16 << 16) | c00, (c48 << 16) | c32);
    };
    UnsignedLong.fromString = function (str) {
        var result = UnsignedLong.fromU32(0);
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size));
            if (size < 8) {
                var power = UnsignedLong.fromU32(Math.pow(10, size));
                result = result.multiply(power).add(UnsignedLong.fromU32(value));
            }
            else {
                result = result.multiply(UnsignedLong.fromU32(100000000));
                result = result.add(UnsignedLong.fromU32(value));
            }
        }
        return result;
    };
    return UnsignedLong;
}());
export { UnsignedLong };
//# sourceMappingURL=unsigned_long.js.map