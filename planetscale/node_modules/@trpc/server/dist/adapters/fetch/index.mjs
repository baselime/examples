import '../../index-f91d720c.mjs';
import { r as resolveHTTPResponse } from '../../resolveHTTPResponse-68c8befb.mjs';
import { g as getBatchStreamFormatter } from '../../batchStreamFormatter-fc1ffb26.mjs';
import '../../codes-c924c3db.mjs';
import '../../config-4c0f8e88.mjs';
import '../../TRPCError-816ff32e.mjs';
import '../../transformTRPCResponse-1153b421.mjs';
import '../../contentType-93515a46.mjs';

async function fetchRequestHandler(opts) {
    const resHeaders = new Headers();
    const createContext = async ()=>{
        return opts.createContext?.({
            req: opts.req,
            resHeaders
        });
    };
    const url = new URL(opts.req.url);
    const path = url.pathname.slice(opts.endpoint.length + 1);
    const req = {
        query: url.searchParams,
        method: opts.req.method,
        headers: Object.fromEntries(opts.req.headers),
        body: opts.req.headers.get('content-type')?.startsWith('application/json') ? await opts.req.text() : ''
    };
    let resolve;
    const promise = new Promise((r)=>resolve = r);
    let status = 200;
    let isStream = false;
    let controller;
    let encoder;
    let formatter;
    const unstable_onHead = (head, isStreaming)=>{
        for (const [key, value] of Object.entries(head.headers ?? {})){
            /* istanbul ignore if -- @preserve */ if (typeof value === 'undefined') {
                continue;
            }
            if (typeof value === 'string') {
                resHeaders.set(key, value);
                continue;
            }
            for (const v of value){
                resHeaders.append(key, v);
            }
        }
        status = head.status;
        if (isStreaming) {
            resHeaders.set('Transfer-Encoding', 'chunked');
            resHeaders.append('Vary', 'trpc-batch-mode');
            const stream = new ReadableStream({
                start (c) {
                    controller = c;
                }
            });
            const response = new Response(stream, {
                status,
                headers: resHeaders
            });
            resolve(response);
            encoder = new TextEncoder();
            formatter = getBatchStreamFormatter();
            isStream = true;
        }
    };
    const unstable_onChunk = ([index, string])=>{
        if (index === -1) {
            // full response, no streaming
            const response = new Response(string || null, {
                status,
                headers: resHeaders
            });
            resolve(response);
        } else {
            controller.enqueue(encoder.encode(formatter(index, string)));
        }
    };
    resolveHTTPResponse({
        req,
        createContext,
        path,
        router: opts.router,
        batching: opts.batching,
        responseMeta: opts.responseMeta,
        onError (o) {
            opts?.onError?.({
                ...o,
                req: opts.req
            });
        },
        unstable_onHead,
        unstable_onChunk
    }).then(()=>{
        if (isStream) {
            controller.enqueue(encoder.encode(formatter.end()));
            controller.close();
        }
    }).catch(()=>{
        if (isStream) {
            controller.close();
        }
    });
    return promise;
}

export { fetchRequestHandler };
