'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var config = require('../config-3ab6b85e.js');
var TRPCError = require('../TRPCError-ae7b67e8.js');
var observable = require('../observable-464116ac.js');
var transformTRPCResponse = require('../transformTRPCResponse-e65f34e9.js');
require('../index-784ff647.js');
require('../codes-87f6824b.js');

/* istanbul ignore next -- @preserve */ function assertIsObject(obj) {
    if (typeof obj !== 'object' || Array.isArray(obj) || !obj) {
        throw new Error('Not an object');
    }
}
/* istanbul ignore next -- @preserve */ function assertIsProcedureType(obj) {
    if (obj !== 'query' && obj !== 'subscription' && obj !== 'mutation') {
        throw new Error('Invalid procedure type');
    }
}
/* istanbul ignore next -- @preserve */ function assertIsRequestId(obj) {
    if (obj !== null && typeof obj === 'number' && isNaN(obj) && typeof obj !== 'string') {
        throw new Error('Invalid request id');
    }
}
/* istanbul ignore next -- @preserve */ function assertIsString(obj) {
    if (typeof obj !== 'string') {
        throw new Error('Invalid string');
    }
}
/* istanbul ignore next -- @preserve */ function assertIsJSONRPC2OrUndefined(obj) {
    if (typeof obj !== 'undefined' && obj !== '2.0') {
        throw new Error('Must be JSONRPC 2.0');
    }
}
function parseMessage(obj, transformer) {
    assertIsObject(obj);
    const { method , params , id , jsonrpc  } = obj;
    assertIsRequestId(id);
    assertIsJSONRPC2OrUndefined(jsonrpc);
    if (method === 'subscription.stop') {
        return {
            id,
            jsonrpc,
            method
        };
    }
    assertIsProcedureType(method);
    assertIsObject(params);
    const { input: rawInput , path  } = params;
    assertIsString(path);
    const input = transformer.input.deserialize(rawInput);
    return {
        id,
        jsonrpc,
        method,
        params: {
            input,
            path
        }
    };
}
function applyWSSHandler(opts) {
    const { wss , createContext , router  } = opts;
    const { transformer  } = router._def._config;
    wss.on('connection', async (client, req)=>{
        const clientSubscriptions = new Map();
        function respond(untransformedJSON) {
            client.send(JSON.stringify(transformTRPCResponse.transformTRPCResponse(router._def._config, untransformedJSON)));
        }
        function stopSubscription(subscription, { id , jsonrpc  }) {
            subscription.unsubscribe();
            respond({
                id,
                jsonrpc,
                result: {
                    type: 'stopped'
                }
            });
        }
        const ctxPromise = createContext?.({
            req,
            res: client
        });
        let ctx = undefined;
        async function handleRequest(msg) {
            const { id , jsonrpc  } = msg;
            /* istanbul ignore next -- @preserve */ if (id === null) {
                throw new TRPCError.TRPCError({
                    code: 'BAD_REQUEST',
                    message: '`id` is required'
                });
            }
            if (msg.method === 'subscription.stop') {
                const sub = clientSubscriptions.get(id);
                if (sub) {
                    stopSubscription(sub, {
                        id,
                        jsonrpc
                    });
                }
                clientSubscriptions.delete(id);
                return;
            }
            const { path , input  } = msg.params;
            const type = msg.method;
            try {
                await ctxPromise; // asserts context has been set
                const result = await config.callProcedure({
                    procedures: router._def.procedures,
                    path,
                    rawInput: input,
                    ctx,
                    type
                });
                if (type === 'subscription') {
                    if (!observable.isObservable(result)) {
                        throw new TRPCError.TRPCError({
                            message: `Subscription ${path} did not return an observable`,
                            code: 'INTERNAL_SERVER_ERROR'
                        });
                    }
                } else {
                    // send the value as data if the method is not a subscription
                    respond({
                        id,
                        jsonrpc,
                        result: {
                            type: 'data',
                            data: result
                        }
                    });
                    return;
                }
                const observable$1 = result;
                const sub1 = observable$1.subscribe({
                    next (data) {
                        respond({
                            id,
                            jsonrpc,
                            result: {
                                type: 'data',
                                data
                            }
                        });
                    },
                    error (err) {
                        const error = TRPCError.getTRPCErrorFromUnknown(err);
                        opts.onError?.({
                            error,
                            path,
                            type,
                            ctx,
                            req,
                            input
                        });
                        respond({
                            id,
                            jsonrpc,
                            error: transformTRPCResponse.getErrorShape({
                                config: router._def._config,
                                error,
                                type,
                                path,
                                input,
                                ctx
                            })
                        });
                    },
                    complete () {
                        respond({
                            id,
                            jsonrpc,
                            result: {
                                type: 'stopped'
                            }
                        });
                    }
                });
                /* istanbul ignore next -- @preserve */ if (client.readyState !== client.OPEN) {
                    // if the client got disconnected whilst initializing the subscription
                    // no need to send stopped message if the client is disconnected
                    sub1.unsubscribe();
                    return;
                }
                /* istanbul ignore next -- @preserve */ if (clientSubscriptions.has(id)) {
                    // duplicate request ids for client
                    stopSubscription(sub1, {
                        id,
                        jsonrpc
                    });
                    throw new TRPCError.TRPCError({
                        message: `Duplicate id ${id}`,
                        code: 'BAD_REQUEST'
                    });
                }
                clientSubscriptions.set(id, sub1);
                respond({
                    id,
                    jsonrpc,
                    result: {
                        type: 'started'
                    }
                });
            } catch (cause) /* istanbul ignore next -- @preserve */ {
                // procedure threw an error
                const error = TRPCError.getTRPCErrorFromUnknown(cause);
                opts.onError?.({
                    error,
                    path,
                    type,
                    ctx,
                    req,
                    input
                });
                respond({
                    id,
                    jsonrpc,
                    error: transformTRPCResponse.getErrorShape({
                        config: router._def._config,
                        error,
                        type,
                        path,
                        input,
                        ctx
                    })
                });
            }
        }
        client.on('message', async (message)=>{
            try {
                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                const msgJSON = JSON.parse(message.toString());
                const msgs = Array.isArray(msgJSON) ? msgJSON : [
                    msgJSON
                ];
                const promises = msgs.map((raw)=>parseMessage(raw, transformer)).map(handleRequest);
                await Promise.all(promises);
            } catch (cause) {
                const error = new TRPCError.TRPCError({
                    code: 'PARSE_ERROR',
                    cause
                });
                respond({
                    id: null,
                    error: transformTRPCResponse.getErrorShape({
                        config: router._def._config,
                        error,
                        type: 'unknown',
                        path: undefined,
                        input: undefined,
                        ctx: undefined
                    })
                });
            }
        });
        // WebSocket errors should be handled, as otherwise unhandled exceptions will crash Node.js.
        // This line was introduced after the following error brought down production systems:
        // "RangeError: Invalid WebSocket frame: RSV2 and RSV3 must be clear"
        // Here is the relevant discussion: https://github.com/websockets/ws/issues/1354#issuecomment-774616962
        client.on('error', (cause)=>{
            opts.onError?.({
                ctx,
                error: TRPCError.getTRPCErrorFromUnknown(cause),
                input: undefined,
                path: undefined,
                type: 'unknown',
                req
            });
        });
        client.once('close', ()=>{
            for (const sub of clientSubscriptions.values()){
                sub.unsubscribe();
            }
            clientSubscriptions.clear();
        });
        async function createContextAsync() {
            try {
                ctx = await ctxPromise;
            } catch (cause) {
                const error = TRPCError.getTRPCErrorFromUnknown(cause);
                opts.onError?.({
                    error,
                    path: undefined,
                    type: 'unknown',
                    ctx,
                    req,
                    input: undefined
                });
                respond({
                    id: null,
                    error: transformTRPCResponse.getErrorShape({
                        config: router._def._config,
                        error,
                        type: 'unknown',
                        path: undefined,
                        input: undefined,
                        ctx
                    })
                });
                // close in next tick
                (global.setImmediate ?? global.setTimeout)(()=>{
                    client.close();
                });
            }
        }
        await createContextAsync();
    });
    return {
        broadcastReconnectNotification: ()=>{
            const response = {
                id: null,
                method: 'reconnect'
            };
            const data = JSON.stringify(response);
            for (const client of wss.clients){
                if (client.readyState === 1 /* ws.OPEN */ ) {
                    client.send(data);
                }
            }
        }
    };
}

exports.applyWSSHandler = applyWSSHandler;
exports.parseMessage = parseMessage;
