import { ResourceAttributes } from '@opentelemetry/resources';
import { InstrumentationOption } from '@opentelemetry/instrumentation';
import * as _trpc_server from '@trpc/server';
import { IncomingMessage, ClientRequest, ServerResponse } from 'http';
import { HttpInstrumentation, HttpInstrumentationConfig } from '@opentelemetry/instrumentation-http';

type BaselimeSDKOpts = {
    instrumentations?: InstrumentationOption[];
    collectorUrl?: string;
    baselimeKey?: string;
    service?: string;
    namespace?: string;
    serverless?: boolean;
};
declare class BaselimeSDK {
    options: BaselimeSDKOpts;
    attributes: ResourceAttributes;
    constructor(options: BaselimeSDKOpts);
    start(): void;
}

type TracingOptions = {
    collectInput?: boolean;
    collectResult?: boolean;
    instrumentedContextFields?: string[];
    headers?: string[];
};
declare function tracing(options?: TracingOptions): _trpc_server.MiddlewareBuilder<{
    _config: _trpc_server.RootConfig<{
        ctx: object;
        meta: object;
        errorShape: object;
        transformer: object;
    }>;
    _ctx_out: {};
    _input_out: unknown;
    _input_in: unknown;
    _output_in: unknown;
    _output_out: unknown;
    _meta: object;
}, {
    _config: _trpc_server.RootConfig<{
        ctx: object;
        meta: object;
        errorShape: object;
        transformer: object;
    }>;
    _ctx_out: {};
    _input_out: unknown;
    _input_in: unknown;
    _output_in: unknown;
    _output_out: unknown;
    _meta: object;
}>;

declare class HttpPlugin {
    parseIncommingMessage?(request: IncomingMessage): Record<string, unknown>;
    parseClientRequest?(request: ClientRequest): Record<string, unknown>;
    captureBody: boolean;
    name: string;
    constructor();
    shouldParseRequest(request: ClientRequest | IncomingMessage): boolean;
    shouldParseResponse(response: IncomingMessage | ServerResponse<IncomingMessage>): boolean;
}

type BetterHttpInstrumentationOptions = {
    plugins?: HttpPlugin[];
    requestHook?: HttpInstrumentationConfig['requestHook'];
    responseHook?: HttpInstrumentationConfig['responseHook'];
    ignoreIncomingRequestHook?: HttpInstrumentationConfig['ignoreIncomingRequestHook'];
    ignoreOutgoingRequestHook?: HttpInstrumentationConfig['ignoreOutgoingRequestHook'];
    startIncomingSpanHook?: HttpInstrumentationConfig['startIncomingSpanHook'];
    startOutgoingSpanHook?: HttpInstrumentationConfig['startOutgoingSpanHook'];
};
declare class BetterHttpInstrumentation extends HttpInstrumentation {
    constructor(options?: BetterHttpInstrumentationOptions);
}

declare class StripePlugin extends HttpPlugin implements HttpPlugin {
    captureBody: boolean;
    name: string;
    shouldParseRequest(request: ClientRequest | IncomingMessage): boolean;
    parseClientRequest(request: ClientRequest): {
        stripe: {
            version: string;
            method: string;
            entity: string;
            entityIdOrOperation: string;
            operation: string;
        };
    };
}

declare class VercelPlugin extends HttpPlugin implements HttpPlugin {
    name: string;
    shouldParseRequest(request: ClientRequest | IncomingMessage): boolean;
    parseIncommingMessage(request: IncomingMessage): {
        requestId: string;
        faas: {
            execution: string;
        };
        user: {
            ip: string | string[];
            country: string | string[];
            region: string | string[];
            city: string | string[];
            latitude: string | string[];
            longitude: string | string[];
            timezone: string | string[];
        };
    };
}

export { BaselimeSDK, BetterHttpInstrumentation, HttpPlugin, StripePlugin, VercelPlugin, tracing as trpcTracingMiddleware };
